# 코드 스플릿팅  
큰 웹 앱에서 하나의 싱글 파일에 모든 코드들을 작성하는 것은 비효율적인데, 특히 어떤 코드 블록이 
어떤 환경에서만 사용될 경우 더욱 더 그렇다. 웹팩은 코드 베이스를 온디맨드 방식으로 로드되는 "청크"로 분리할 수 있다.
몇 몇 다른 번들러들은 그것을 "layers", "rollups" 혹은 "fragments"라고 부른다. 
웹팩에서는 "code splitting"이라고 부른다.  
  
코드 스플리팅은 옵트인(opt-in) 기능이므로 코드 베이스 안에 스플릿 포인트를 정의할 수 있다.
 웹팩은 의존성, 출력 파일 그리고 런타임 요소들을 중요시한다.  

일반적인 오해를 분명히 하자. 코드 스플리팅은 공통 코드를 공유 청크로 추출하기 위한 것만은 아니다. 
좀 더 주목할 만한 기능은 코드 스플리팅이 온디멘드 방식으로 로드된 청크로 코드를 나누는데 사용할 수 있다는 것이다.
그러므로 코드 스플리팅은 초기 다운로드를 작게 유지시켜주고 애플리케이션에 의해 요구됐을 때 온디맨드 방식으로 코드를 
다운로드 받게 된다.  

## 스플리팅 포인트 정의 하기
AMD와 CommonJS는 온디맨드 방식으로 코드를 로드하기 위해 서로 다른 방법을 정의한다.

### require.ensure (CommonJS)

    require.ensure(dependencies, callback)
    
require.ensure 메서드는 dependencies 내 모든 의존성들이 callback을 호출할 때 동기 방식으로 요청되는 
것을 보증한다. callback은 호출될 때, require 함수를 파라미터로 받는다.
    
    require.ensure(['module-a', 'module-b'], function(require) {
        var a = require('module-a');
        //...
    }

참고 require.ensure는 모듈을 로드할 뿐 평가하지 않는다.

### require(AMD)

    require(dependencies, callback)
    
위 함수가 호출되면, 모든 의존성이 로드되고, callback은 로드된 의존성의 exports 와 함께 호출된다.
    
    require(['module-a','module-b'],callback

### es6 modules  
tldr: 웹팩은 es6 모듈을 지원하지 않는다. 당신의 변환 컴파일러가 생성한 모듈상에서 require.ensure 또는 require를 사용해라.  
  
webpack 1.x는 es6를 지원하지 않지만, 2.x부터는 지원하다. 하지만 바벨 같은 변환 컴파일러를 사용할 수 있다. 이런한 접근은
효과적이지만, 동적 로딩이라는 중요한 caveat을 가진다.  
  
import 문법은 내부적으로 정적 분석이 가능하게 설계되어 있다. 즉 그것은 동적 임포트는 불가능하다는 것이다.
  
    // INVALID!!!!!!!!!
    ['lodash', 'backbone'].forEach(name => import name )

운 좋게는 거기에 동적 사용 케이스를 조작하기 위한 loader 라는 자바스크립트 API가 있다. 이 API는 앞서 이야기된 require 변수와 
동등하다. 하지만, 대부분의 변형 컴퍼일러는 System.load의 컨버팅을 지원하지 않는다.(동적 코드 스플릿팅을 직접 사용하기 위한 require.ensure
을 호출한는 System.load)
        
    //static imports
    import _ from 'lodash'
    
    // dynamic imports
    require.ensure([], function(require) {
      let contacts = require('./contacts')
    })
        
뭔 말이지는 모르겠다만, import는 동적 지원은 하지 않으니 그냥 require.ensure를 사용하라는 이야기인듯 하다.

## 청크 컨텐츠
스플릿 포인트에서 모든 의존성은 새로운 청크로 이동한다. 의존성들은 또한 재귀적으로 추가된다.  
  
함수 표현식을 콜백으로 스플릿 포인트에 전달할 경우(혹은 바인딩할 경우), 웹팩은 자동으로 함수 
표현식에서 요청되는 모든 의존성 또한 청크로 전달한다.

## 청크 최적화
두 개의 청크가 같은 모듈을 포함할 경우, 그것들은 하나로 합쳐지게 된다. 
그래서 청크는 여러 개의 상위 청크를 가질 수 있다.
모듈이 모든 부모 청크에서 사용 가능할 경우, 해당 청크로부터 제거된다.
청크가 또 다른 청크의 모든 모듈을 포함할 경우, 해당 청크는 저장되며, 여러 청크들을 만족시키게 된다.
      
## 청크 로딩
target이라는 설정 옵션에 따르면, 청크 로딩을 위한 런타임 로직은 번들에 추가된다. 
예를 들어, web 타겟에 대해 청크는 jsonp를 통해 로드된다. 청크는 한번만 로드되며 병렬 요청은 하나로 합쳐지게 된다. 
로드된 청크에 대해서 그들이 여러 청크들을 만족시키는지 런타임에 체크하게 된다.
  
## 청크 유형  
### 엔트리 청크  
엔트리 청크는 런타임과 함께 모듈 묶음을 포함한다. 청크가 모듈 0를 포함할 경우, 
런타임은 그것을 실행하게 된다. 그렇지 않을 경우, 모듈 0을 포함하는 청크가 
전달되기를 기다린 후에 그것을 실행한다.(모듈 0가 포함된 청크가 있을 때마다 매번)
### 일반 청크
일반 청크는 런타임을 포함하지 않는다. 오로지 모듈 묶음을 포함한다. 
구조는 청크 로딩 알고리즘에 의존한다. 예를 들자면, jsonp에 대한 모듈들은 jsonp 콜백 함수로 둘러쌓여있다. 
청크는 또한 충족할만한 청크 아이디 목록을 포함하고 있다.
### 초기 청크(non-entry)
초기 청크는 일반 청크와 같다. 딱 하나의 차이점이라면, 최적화가 그것을 좀 더 중요하게 처리한다는 것인데, 
(엔트리 청크처럼)초기 로딩 시간를 향해 카운트되기 때문이다. 이 청크 유형은 CommonsChunkPlugin과 
결합해야 사용 가능하다.  

